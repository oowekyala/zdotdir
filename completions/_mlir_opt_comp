#compdef tilefirst-opt mlir-opt

__mlir_opt_comp_helper_path() {
    if (( $+functions_source[_mlir_opt_comp] )); then
        local src=${functions_source[_mlir_opt_comp]}
        if [[ -n $src ]]; then
            print -r -- "${src:h}/mlir_opt_comp_helper.py"
            return 0
        fi
    fi
    print -r -- "$HOME/.config/zsh/completions/mlir_opt_comp_helper.py"
}

__mlir_opt_comp_helper_call() {
    local helper=$1
    shift
    local -a args
    if [[ -n $MLIR_OPT_COMP_CMD ]]; then
        args+=(--cmd "$MLIR_OPT_COMP_CMD")
    fi
    args+=(--no-cache)
    args+=("$@")
    "$helper" "${args[@]}"
}

__mlir_opt_comp_values() {
    local helper=$1 base=$2
    local output
    output=$(__mlir_opt_comp_helper_call "$helper" list-values "$base" 2>/dev/null) || return 1
    [[ -z $output ]] && return 1

    local -a entries value_specs
    entries=(${(0)output})
    local field_sep=$'\x1f'
    local entry
    for entry in "${entries[@]}"; do
        local -a parts
        parts=(${(ps:$field_sep:)entry})
        local value=${parts[1]}
        local desc=${parts[2]}
        [[ -z $value ]] && continue
        desc=${desc//:/\\:}
        value_specs+=("$value:$desc")
    done
    (( ${#value_specs} )) || return 1
    _describe -t mlir-opt-values "values for $base" value_specs -Q
}

__mlir_opt_comp_pass_options() {
    local helper=$1 
    local output opt_name

    opt_name=${${${(Q)PREFIX}%%=*}##\s*}
    compset -P '*='

    output=$(__mlir_opt_comp_helper_call "$helper" list-pass-options -- "$opt_name" 2>/dev/null) || return 1
    [[ -z $output ]] && return 1

    local -a entries specs
    entries=(${(0)output})
    local field_sep=$'\x1f'
    local entry
    for entry in "${entries[@]}"; do
        local -a parts
        parts=(${(ps:$field_sep:)entry})
        local insert=${parts[1]}
        local style=${parts[3]}
        local desc=${parts[4]:-${parts[1]}}
        local hint=${parts[5]}
        local value_label=${hint:-value}
        value_label=${value_label// /_}
        value_label=${value_label//:/_}
        desc=${desc//]/\\]}
        if [[ -z "$hint" ]]; then
          specs+=("${insert}[$desc]")
        else
          # TODO need to list possible values using :(a b c) form in the spec
          specs+=("${insert}[$desc]:$hint:")
        fi
    done
    (( ${#specs[@]} )) || return 1
    _values -S ' ' "Options for $opt_name" "${specs[@]}"
}

# Delete the space when typing = after an option name, allows typing pass options 
_mlir_opt_comp_equal_handler() {
    [[ $1 = 1 && $LBUFFER[-1] = ' ' && $KEYS = '=' ]] || return
    LBUFFER="${LBUFFER[1,-2]}="
}

_mlir_opt_comp() {
    local helper=$(__mlir_opt_comp_helper_path)
    [[ -x $helper ]] || return 1

    if [[ "$PREFIX" = *=* ]]; then
      __mlir_opt_comp_pass_options "$helper"
      return
    fi

    local output
    output=$(__mlir_opt_comp_helper_call "$helper" list-options 2>/dev/null) || return 1
    [[ -z $output ]] && return 1

    local -a entries arg_specs
    entries=(${(0)output})
    local field_sep=$'\x1f'
    typeset -A state_option_map option_styles pass_has_options
    local idx=1
    local entry
    for entry in "${entries[@]}"; do
        local -a parts
        parts=(${(ps:$field_sep:)entry})
        local base=${parts[1]}
        local style=${parts[3]}
        local desc=${parts[4]:-$base}
        local hint=${parts[5]}
        local has_pass_options=${parts[6]}
        desc=${desc//]/\\]}
        local value_label=${hint:-value}
        value_label=${value_label// /_}
        value_label=${value_label//:/_}
        local state_name=''
        option_styles[$base]=$style
        pass_has_options[$base]=$has_pass_options

        state_name="mliropt${idx}"
        ((idx++))
        state_option_map[$state_name]=$base
        case $style in
            flag)
                if [[ $has_pass_options == 1 ]]; then 
                  arg_specs+=("*${base}=[$desc]::->$state_name")
                else
                  arg_specs+=("*${base}[$desc]")
                fi
                ;;
            attached)
                arg_specs+=("*${base}=[$desc]:$value_label:->$state_name")
                ;;
            separate)
                arg_specs+=("*${base}[$desc]:$value_label:->$state_name")
                ;;
        esac
    done

    local -a _mlir_arguments
    _mlir_arguments=()
    (( ${#arg_specs[@]} )) && _mlir_arguments+=("${arg_specs[@]}")
    _mlir_arguments+=('*:file:_files')


    local state
    _arguments -S : "${_mlir_arguments[@]}" && return 0

    case $state in
        mliropt*)
            local option_name=${state_option_map[$state]}
            if [[ -n $option_name ]]; then
                local opt_style=${option_styles[$option_name]}
                local has_options=${pass_has_options[$option_name]}
                if [[ $has_options == 1 ]]; then
                    if [[ $opt_style == attached ]]; then
                        if ! compset -P '*='; then
                            _message 'pass option'
                            return
                        fi
                    fi
                    if compset -P '*=' ; __mlir_opt_comp_pass_options "$helper" "$option_name"; then
                      return
                    fi
                    _message 'pass option'
                    return
                else
                    if ! __mlir_opt_comp_values "$helper" "$option_name"; then
                        _message 'value'
                    fi
                fi
            fi
            ;;
    esac
}
